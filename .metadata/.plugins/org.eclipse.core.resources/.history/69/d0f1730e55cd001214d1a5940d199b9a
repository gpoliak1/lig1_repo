#include <GL/gl.h>
#include <GL/glut.h>
#include <iostream>
#include <list>

using namespace std;

bool const doublebuffered = true;

struct point {
	int x;
	int y;
};

typedef list<point> t_pointlist;
t_pointlist pointlist;

int window_width = 0;
int window_height = 0;

void reshape(int width, int height) {
	// use reshape function to gather new window dimensions
	window_width = width;
	window_height = height;

	// force a redraw of the window
	glutPostRedisplay();

}

void display(void) {
	// Always(!) set OpenGL in the proper state
	// before the relevant drawing calls.
	// Don't rely on the state being prepared at
	// other places, left in the right condition.

	// 1. Set the proper viewport
	glViewport(0, 0, window_width, window_height);

	// 2. Clearing
	// First define the clearing parameters...
	glClearColor(0.f, 0.f, 0.f, 1.f);
	// ... then call the clear function
	glClear(GL_COLOR_BUFFER_BIT);

	// 3. set up the transformation matrices
	// order is not important, but usually
	// one first sets projection
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	// note that I placed window_height in the "bottom" parameter.
	// OpenGL has the coordinate origin in the lower left of the viewport.
	// By putting the window height in the bottom this is reversed.
	glOrtho(0, window_width, window_height, 0, -1, 1);
	// Then set the modelview. For now, this is just identity
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	!glBegin(GL_LINES);
	glColor4f(1., 1., 1., 1.);
	for (t_pointlist::iterator iter = pointlist.begin();
			iter != pointlist.end(); ++iter) {
		point p1, p2;

		p1 = *iter;
		if (++iter == pointlist.end())
			break;
		p2 = *iter;

		glVertex2f(p1.x, p1.y);
		glVertex2f(p2.x, p2.y);
	}
	glEnd();

	glPointSize(3.);
	glBegin(GL_POINTS);
	glColor4f(0., 1., 0., 1.);
	for (t_pointlist::iterator iter = pointlist.begin();
			iter != pointlist.end(); ++iter) {
		glVertex2f(iter->x, iter->y);
	}
	glEnd();

	// finally finish (if single buffered) or swap (if double buffered)
	if (doublebuffered)
		glutSwapBuffers();
	else
		glFinish();

}

void mouse(int button, int state, int x, int y) {
	static int prev_state[3] = { -1, -1, -1 };

	if (prev_state[button] == GLUT_DOWN && state == GLUT_UP) {
		// button clicked (i.e. pressed and depressed)
		if (button == GLUT_LEFT_BUTTON) {
			point p = { x, y };
			pointlist.push_back(p);
		}
	}

	prev_state[button] = state;

	glutPostRedisplay();

}

int main(int argc, char** argv) {
	glutInit(&argc, argv);
	glutInitDisplayMode(
			(doublebuffered ? GLUT_DOUBLE : GLUT_SINGLE) | GLUT_RGB);
	glutInitWindowSize(250, 250);

	glutCreateWindow("Hello");
	glutMouseFunc(mouse);
	glutReshapeFunc(reshape);
	glutDisplayFunc(display);

	glutMainLoop();

	return 0;

}
